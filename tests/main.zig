//! Cross-validation tests for HyperZig against Rust SDK test vectors.
//!
//! These tests verify byte-exact compatibility with the Rust hypersdk.
//! Test vectors generated by: reference/tests/generate_vectors.rs

const std = @import("std");
const hyperzig = @import("hyperzig");
const crypto = hyperzig.crypto;
const eip712 = crypto.eip712;
const Signer = crypto.signer.Signer;
const keccak256 = crypto.signer.keccak256;

// ── Helper: parse hex string to bytes ────────────────────────────

fn hexToBytes(comptime len: usize, hex: *const [len * 2]u8) [len]u8 {
    var result: [len]u8 = undefined;
    for (0..len) |i| {
        result[i] = std.fmt.parseInt(u8, hex[i * 2 ..][0..2], 16) catch unreachable;
    }
    return result;
}

fn hexToBytes32(hex: []const u8) [32]u8 {
    const s = if (hex.len >= 2 and hex[0] == '0' and hex[1] == 'x') hex[2..] else hex;
    var result: [32]u8 = undefined;
    for (0..32) |i| {
        result[i] = std.fmt.parseInt(u8, s[i * 2 ..][0..2], 16) catch unreachable;
    }
    return result;
}

fn hexToBytes20(hex: []const u8) [20]u8 {
    const s = if (hex.len >= 2 and hex[0] == '0' and hex[1] == 'x') hex[2..] else hex;
    var result: [20]u8 = undefined;
    for (0..20) |i| {
        result[i] = std.fmt.parseInt(u8, s[i * 2 ..][0..2], 16) catch unreachable;
    }
    return result;
}

// ── Test vectors from Rust SDK ───────────────────────────────────
// Values from tests/vectors/rust_vectors.json

const TEST_PRIVATE_KEY = "e908f86dbb4d55ac876378565aafeabc187f6690f046459397b17d9b9a19688e";
const EXPECTED_ADDRESS = "0xcd49bbac6e85fdeb167eb7ca41a945d2b8758f6f";

// Domain separators
const EXPECTED_CORE_DOMAIN_SEP = "0xd79297fcdf2ffcd4ae223d01edaa2ba214ff8f401d7c9300d995d17c82aa4040";
const EXPECTED_MAINNET_DOMAIN_SEP = "0x2f54e643b38c9c2b65cb731aaf11c54f01705ee0cdf45aea16e2ac0a5ce7531a";
const EXPECTED_TESTNET_DOMAIN_SEP = "0xfeb1393ca4412a4ca577bd51d04f0a77033514c602f4d0a11490fb95f7428df6";

// Agent type hash
const EXPECTED_AGENT_TYPE_HASH = "0x26f05c2f7239b6983075e58321292d77b3aa173d19b27257ac96ab362570f508";

// Agent signing vectors
const EXPECTED_AGENT_CONNECTION_ID = "0x53fa6d12be596a78d8b61e65851b1e5cfb91f81361f6570923b3b69e1390e937";
const EXPECTED_AGENT_STRUCT_HASH = "0x7126440dffa91e487262ade5f741cafd792ea44e24ae91b6a29b0e413240556d";
const EXPECTED_AGENT_SIGNING_HASH = "0x7d67dd07e5d0a4bdded87df506e26f1f1e1169a513dba3cc1a1114fac1fd70bf";
const EXPECTED_AGENT_SIGNATURE = "0xa3a46e29accf87e49ca132da1146eba96e5441bdb674a275ca90dbe805a192fe06a83e75e14700f2f6112ea079f7cd427c2a229828c3b83f1be9dd0afb32bd581b";

// UsdSend signature
const EXPECTED_USD_SEND_SIGNATURE = "0xeca6267bcaadc4c0ae1aed73f5a2c45fcdbb7271f2e9356992404e5d4bad75a3572e08fe93f17755abadb7f84be7d1e9c4ce48bb5633e339bc430c672d5a20ed1b";

// ── 1. Signer Address ────────────────────────────────────────────

test "cross-validation: signer address matches Rust" {
    const signer = try Signer.fromHex(TEST_PRIVATE_KEY);
    const expected = hexToBytes20(EXPECTED_ADDRESS);
    try std.testing.expectEqualSlices(u8, &expected, &signer.address);
}

// ── 2. Domain Separators ─────────────────────────────────────────

test "cross-validation: core domain separator matches Rust" {
    const expected = hexToBytes32(EXPECTED_CORE_DOMAIN_SEP);
    try std.testing.expectEqualSlices(u8, &expected, &eip712.CORE_DOMAIN_SEPARATOR);
}

test "cross-validation: mainnet domain separator matches Rust" {
    const expected = hexToBytes32(EXPECTED_MAINNET_DOMAIN_SEP);
    try std.testing.expectEqualSlices(u8, &expected, &eip712.MAINNET_DOMAIN_SEPARATOR);
}

test "cross-validation: testnet domain separator matches Rust" {
    const expected = hexToBytes32(EXPECTED_TESTNET_DOMAIN_SEP);
    try std.testing.expectEqualSlices(u8, &expected, &eip712.TESTNET_DOMAIN_SEPARATOR);
}

// ── 3. Type Hashes ───────────────────────────────────────────────

test "cross-validation: Agent type hash matches Rust" {
    const expected = hexToBytes32(EXPECTED_AGENT_TYPE_HASH);
    try std.testing.expectEqualSlices(u8, &expected, &eip712.AGENT_TYPEHASH);
}

test "cross-validation: all type hashes match Rust" {
    // UsdSend — NOTE: Hyperliquid wraps with "HyperliquidTransaction:" prefix
    // The Rust vectors use raw type strings (no prefix) since they come from
    // alloy's sol! macro. But Hyperliquid's get_typed_data adds the prefix.
    // The RAW type hashes (without prefix) from Rust:
    const expected_usd = hexToBytes32("0x5dc95b6aaf87009ca33f04c6f253abdf4645519366990eddce8098f1b873a5a4");
    const raw_usd_hash = keccak256("UsdSend(string hyperliquidChain,string destination,string amount,uint64 time)");
    try std.testing.expectEqualSlices(u8, &expected_usd, &raw_usd_hash);

    const expected_spot = hexToBytes32("0x4e18b46f6880718209d75268cf607c5d85666f94e61b30f6fbce9382fc7c074d");
    const raw_spot_hash = keccak256("SpotSend(string hyperliquidChain,string destination,string token,string amount,uint64 time)");
    try std.testing.expectEqualSlices(u8, &expected_spot, &raw_spot_hash);

    const expected_send_asset = hexToBytes32("0x5caeecbaa73921bc992053948945190f256cf101740f2a839dfcb7b35b8999d3");
    const raw_send_asset_hash = keccak256("SendAsset(string hyperliquidChain,string destination,string sourceDex,string destinationDex,string token,string amount,string fromSubAccount,uint64 nonce)");
    try std.testing.expectEqualSlices(u8, &expected_send_asset, &raw_send_asset_hash);

    const expected_approve = hexToBytes32("0x4bcaeec154f3072cca4f8fb0054aa2093a2ee67752a84c408cac9025350218e1");
    const raw_approve_hash = keccak256("ApproveAgent(string hyperliquidChain,address agentAddress,string agentName,uint64 nonce)");
    try std.testing.expectEqualSlices(u8, &expected_approve, &raw_approve_hash);

    const expected_convert = hexToBytes32("0x4d6d00355e2bd15e5b26b9ad66b32a90e419f3ee519e48884726aae43316a618");
    const raw_convert_hash = keccak256("ConvertToMultiSigUser(string hyperliquidChain,string signers,uint64 nonce)");
    try std.testing.expectEqualSlices(u8, &expected_convert, &raw_convert_hash);

    const expected_send_ms = hexToBytes32("0x850b193262dcd1ccd178e50094ebb5350d6366112c624349b7b8f925b8261911");
    const raw_send_ms_hash = keccak256("SendMultiSig(string hyperliquidChain,bytes32 multiSigActionHash,uint64 nonce)");
    try std.testing.expectEqualSlices(u8, &expected_send_ms, &raw_send_ms_hash);
}

// ── 4. Agent Struct Hash ─────────────────────────────────────────

test "cross-validation: Agent struct hash matches Rust" {
    // connection_id = keccak256("test connection")
    const connection_id = keccak256("test connection");
    const expected_cid = hexToBytes32(EXPECTED_AGENT_CONNECTION_ID);
    try std.testing.expectEqualSlices(u8, &expected_cid, &connection_id);

    // Agent struct hash
    const struct_hash = eip712.hashAgent("a", connection_id);
    const expected = hexToBytes32(EXPECTED_AGENT_STRUCT_HASH);
    try std.testing.expectEqualSlices(u8, &expected, &struct_hash);
}

// ── 5. Agent Signing Hash ────────────────────────────────────────

test "cross-validation: Agent signing hash matches Rust" {
    const connection_id = keccak256("test connection");
    const struct_hash = eip712.hashAgent("a", connection_id);
    const signing_hash = eip712.signingHash(eip712.CORE_DOMAIN_SEPARATOR, struct_hash);
    const expected = hexToBytes32(EXPECTED_AGENT_SIGNING_HASH);
    try std.testing.expectEqualSlices(u8, &expected, &signing_hash);
}

// ── 6. Agent Signature ───────────────────────────────────────────

test "cross-validation: Agent signature matches Rust" {
    const signer = try Signer.fromHex(TEST_PRIVATE_KEY);
    const connection_id = keccak256("test connection");

    const sig = try eip712.signAgent(signer, true, connection_id);
    const sig_bytes = sig.toEthBytes();

    // Parse expected signature
    const expected_hex = EXPECTED_AGENT_SIGNATURE[2..]; // strip "0x"
    var expected: [65]u8 = undefined;
    for (0..65) |i| {
        expected[i] = std.fmt.parseInt(u8, expected_hex[i * 2 ..][0..2], 16) catch unreachable;
    }

    try std.testing.expectEqualSlices(u8, &expected, &sig_bytes);
}

// ── 7. UsdSend Signature ─────────────────────────────────────────

test "cross-validation: UsdSend signature matches Rust" {
    const signer = try Signer.fromHex(TEST_PRIVATE_KEY);

    // NOTE: destination must be lowercase (matching Rust's serialize_address_as_hex)
    const sig = try eip712.signUsdSend(
        signer,
        true,
        "0x0d1d9635d0640821d15e323ac8adadfa9c111414",
        "1",
        1690393044548,
    );
    const sig_bytes = sig.toEthBytes();

    // Parse expected
    const expected_hex = EXPECTED_USD_SEND_SIGNATURE[2..];
    var expected: [65]u8 = undefined;
    for (0..65) |i| {
        expected[i] = std.fmt.parseInt(u8, expected_hex[i * 2 ..][0..2], 16) catch unreachable;
    }

    try std.testing.expectEqualSlices(u8, &expected, &sig_bytes);

    // Also verify we can recover the signer address
    const struct_hash = eip712.hashUsdSend("Mainnet", "0x0d1d9635d0640821d15e323ac8adadfa9c111414", "1", 1690393044548);
    const signing_hash = eip712.signingHash(eip712.MAINNET_DOMAIN_SEPARATOR, struct_hash);
    const recovered = try Signer.recoverAddress(sig, signing_hash);
    try std.testing.expectEqualSlices(u8, &signer.address, &recovered);
}

// ── 8. Msgpack + Decimal ─────────────────────────────────────────

test "cross-validation: decimal normalize matches Rust" {
    const Decimal = hyperzig.math.decimal.Decimal;
    var buf: [64]u8 = undefined;

    // "10.0" → "10" (matches rust_decimal::normalize)
    const d1 = try Decimal.fromString("10.0");
    const s1 = try d1.normalize().toString(&buf);
    try std.testing.expectEqualStrings("10", s1);

    // "0.100" → "0.1"
    const d2 = try Decimal.fromString("0.100");
    const s2 = try d2.normalize().toString(&buf);
    try std.testing.expectEqualStrings("0.1", s2);

    // "100" → "100"
    const d3 = try Decimal.fromString("100");
    const s3 = try d3.normalize().toString(&buf);
    try std.testing.expectEqualStrings("100", s3);

    // "1.23" → "1.23"
    const d4 = try Decimal.fromString("1.23");
    const s4 = try d4.normalize().toString(&buf);
    try std.testing.expectEqualStrings("1.23", s4);
}
